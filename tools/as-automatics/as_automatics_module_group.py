# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# This file is part of the ASTERICS Framework.
# (C) 2019 Hochschule Augsburg, University of Applied Sciences
# -----------------------------------------------------------------------------
"""
as_automatics_module_group.py

Company:
Efficient Embedded Systems Group
University of Applied Sciences, Augsburg, Germany
http://ees.hs-augsburg.de

Author:
Philip Manke

Description:
Class representing an ASTERICS module group part of an ASTERICS processing chain.
"""
# --------------------- LICENSE -----------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
# or write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# --------------------- DOXYGEN -----------------------------------------------
##
# @file as_automatics_module_group.py
# @ingroup automatics_intrep
# @author Philip Manke
# @brief Class representing a module group part of an ASTERICS processing chain.
# -----------------------------------------------------------------------------

import itertools as ittls
import copy

from enum import Enum

import as_automatics_logging as as_log
import as_automatics_helpers as as_help

from as_automatics_connection_helper import get_parent_module, resolve_generic
from as_automatics_module import AsModule
from as_automatics_port import Port
from as_automatics_generic import Generic
from as_automatics_constant import Constant
from as_automatics_signal import GlueSignal, GenericSignal
from as_automatics_interface import Interface
from as_automatics_register import SlaveRegisterInterface
from as_automatics_exceptions import AsNameError
from as_automatics_vhdl_static import REGMGR_REGISTER_CONFIG_NAMES


LOG = as_log.get_log()

ZERO_SIGNAL = GenericSignal("'0'")
ONE_SIGNAL = GenericSignal("'1'")
DC_SIGNAL = GenericSignal("'-'")

# Register type enums
Register = Enum("Register", "none control status both")


## @ingroup automatics_intrep
class AsModuleGroup(AsModule):
    """! @brief Class representing a module containing more modules.
    Same as a module with some additional parameters and methods
    to support a list of submodules that are instantiated in this module.
    Can be used to be inherited by a class implementing custom functionality
    managing a list of submodules.
    A register interface can be added to AsModuleGroups using the provided
    Python methods.
    Each AsModuleGroup will be generated using Automatics' VHDLWriter."""

    def __init__(self, name: str, parent: AsModule, sub_modules: list):
        super().__init__(name)
        self.assign_to(parent)
        if self.parent is not None:
            self.parent.modules.append(self)
        self.description = (
            "ASTERICS module group '{}' file generated by Automatics"
        ).format(self.name)
        self.signals = []
        self.constants = []
        self.vhdl_libraries = ["helpers"]
        self.modules = sub_modules
        self.static_code = {"signals": [], "body": []}
        self.dynamic_code_generators = [self.__generate_register_vhdl__]
        self.bundles = {"and": [], "or": [], "xor": [], "xnor": []}

        self.register_if = None
        self.reg_assign_map_control = {}
        self.reg_assign_map_status = {}
        self.register_count = 0
        self.register_config = dict()
        self.regmod = None

        # Add standard reset and clk signals and ports
        self.add_standard_port(Port("reset", port_type="external"))
        self.add_standard_port(Port("clk", port_type="external"))
        self.get_port("reset").overwrite_rule("external_port", "none")

    ## @ingroup automatics_connection
    def __connect__(self, source, target):
        self.chain.__connect__(source, target, top=self)

    ## @ingroup automatics_connection
    def auto_connect(self):
        self.__update_generics_list__()
        # Apply vector assignments
        for signal in self.signals:
            try:
                signal.__process_vector_assignment_tasks__()
            except AttributeError:
                pass

    ## @ingroup automatics_generate
    def __generate_register_vhdl__(self, chain, code_dict: dict):
        # Skip everything if no register interface is present
        if self.register_if is None:
            return None
        # Comment in VHDL
        code_dict["body"].append("  -- Register assignments:")
        # Assign configuration constant to config port
        code_dict["body"].append(
            "  slv_reg_config <= {};".format(self.register_if.config.code_name)
        )
        code_dict["body"].append(
            "  slv_reg_modify <= {};".format(self.regmod.code_name)
        )
        # Assign to and from register interfaces
        for idx in sorted(self.reg_assign_map_control.keys()):
            target = self.reg_assign_map_control[idx]
            code_dict["body"].append(
                "  {} <= slv_ctrl_reg({});".format(target.code_name, idx)
            )
        for idx in sorted(self.reg_assign_map_status.keys()):
            source = self.reg_assign_map_status[idx]
            code_dict["body"].append(
                "  slv_status_reg({}) <= {};".format(idx, source.code_name)
            )

    def add_register(self, register_type: Register):
        """! @brief Add a register to this module group.
        Use asterics.Register.<type>!
        This is automatically called when using 'assign_port_to_register' or
        'assign_register_to_port' on an index that has no register associated.
        @param register_type  The type/data direction of the new register
        """
        if not isinstance(register_type, Enum):
            raise ValueError(
                (
                    "Invalid parameter passed to 'add_register'! "
                    "Use 'asterics.Register.<type> with <type> as one of "
                    "[none, control, status, both]."
                )
            )
        if self.register_count == 0:
            self._add_register_interface()
        regtype = REGMGR_REGISTER_CONFIG_NAMES[register_type.name]
        self.register_config[self.register_count] = regtype

        if regtype in ("AS_REG_NONE", "AS_REG_CONTROL"):
            self.regmod.assign_to_this_vector(ZERO_SIGNAL, self.register_count)
        elif regtype == "AS_REG_STATUS":
            self.regmod.assign_to_this_vector(ONE_SIGNAL, self.register_count)
        elif regtype == "AS_REG_BOTH":
            self.regmod.assign_to_this_vector(DC_SIGNAL, self.register_count)

        # New register added!
        self.register_count += 1
        self._update_register_params()

    ## @ingroup automatics_connection
    def _update_register_params(self):
        # Update config constant value
        self.register_if.config.value = (
            as_help.generate_register_config_value_string(self.register_config)
        )
        # Update register interface port's data width
        for port in ittls.chain(
            self.register_if.ports, [self.regmod, self.register_if.config]
        ):
            port.data_width = Port.DataWidth(0, "to", self.register_count - 1)

        # Update register interface parameters
        self.register_if.config_applied = False
        self.register_if.__decode_slvreg_table__()

    def modify_register_type(
        self, register_num: int, new_type: Register
    ) -> bool:
        """! @brief Modify the type/data direction of an existing register.
        Does normally not have to be called directly, instead is indirectly
        executed when assign_port_to_register or assign_register_to_port is
        called.
        @param register_num  The offset of the register to modify
        @param new_type  The register type (asterics.Register.<type>) to change to
        @return  True on success, else False (register number does not exist)
        """
        if self.register_count <= register_num:
            return False
        old_type = self.register_config[register_num]
        new_type = REGMGR_REGISTER_CONFIG_NAMES[new_type.name]

        if old_type != new_type:
            self.regmod.assign_to_this_vector(None, register_num)
            if new_type in ("AS_REG_NONE", "AS_REG_CONTROL"):
                self.regmod.assign_to_this_vector(ZERO_SIGNAL, register_num)
            elif new_type == "AS_REG_STATUS":
                self.regmod.assign_to_this_vector(ONE_SIGNAL, register_num)
            elif new_type == "AS_REG_BOTH":
                self.regmod.assign_to_this_vector(DC_SIGNAL, register_num)
        self.register_config[register_num] = new_type
        self._update_register_params()
        return True

    def _assign_to_register(
        self, register_index: int, from_signal: GenericSignal
    ):
        """! @brief Assign a signal with matching data width to a register."""
        if register_index >= self.register_count:
            raise ValueError(
                (
                    "Register index out of bounds! Maximum register index "
                    "for module group '{}' is {}."
                ).format(self, self.register_count - 1)
            )
        try:
            # Try to access the register index
            prev = self.reg_assign_map_status[register_index]
            LOG.warning(
                (
                    "Assigning signal '%s' to register index %s in module '%s'. "
                    "Overwriting previous assignment: '%s'!"
                ),
                str(from_signal),
                register_index,
                str(self),
                str(prev),
            )
            self.reg_assign_map_status[register_index] = from_signal
        except KeyError:
            # This index is unassigned -> no problem assigning the signal
            self.reg_assign_map_status[register_index] = from_signal

    def _assign_from_register(
        self, register_index: int, to_signal: GenericSignal
    ):
        """! @brief Assign a register to a signal with matching data width."""
        if register_index >= self.register_count:
            raise ValueError(
                (
                    "Register index out of bounds! Maximum register index for "
                    "module group '{}' is {}."
                ).format(self, self.register_count - 1)
            )

        self.reg_assign_map_control[register_index] = to_signal

    def _add_register_interface(self):
        """! @brief Add a register interface to this module group.
        This method defines and adds the necessary signals to this module group
        comrising an ASTERICS slave register interface.
        This method is called by methods adding port-register connections."""
        # Slave register interface:
        # Create ports for the slave register interface

        ctrl_reg = Port(
            "slv_ctrl_reg",
            data_type="slv_reg_data",
            data_width=Port.DataWidth(0, "to", 0),
        )
        status_reg = Port(
            "slv_status_reg",
            direction="out",
            data_type="slv_reg_data",
            data_width=Port.DataWidth(0, "to", 0),
        )
        mod_reg = Port(
            "slv_reg_modify",
            direction="out",
            data_type="std_logic_vector",
            data_width=Port.DataWidth(0, "to", 0),
        )
        config_reg = Port(
            "slv_reg_config",
            direction="out",
            data_type="slv_reg_config_table",
            data_width=Port.DataWidth(0, "to", 0),
        )
        config_const = Constant(
            "slave_register_configuration",
            data_type="slv_reg_config_table",
            data_width=Port.DataWidth(0, "to", 0),
            value="()",
        )
        self.entity_ports = [config_reg, ctrl_reg, status_reg, mod_reg]
        self.entity_constants = [config_const]
        self.constants = [config_const]

        self.__assign_interfaces__()

        reginter = self.get_slave_register_interface()
        self.register_if = reginter
        self.regmod = self.define_signal("reg_modify_vect", "std_logic_vector")
        # Hack to suppress neutral value assignment; Assigned object is not used
        config_reg.incoming = config_const
        status_reg.incoming = config_const

        mod_reg.connect(self.regmod)

    def __update_generics_list__(self):
        for sig in self.signals:
            as_help.foreach(sig.generics, lambda gen: self.add_generic(gen))

    def update_modlevel(self):
        """! @brief Update the modlevel off all submodules.
        To be called only from toplevel."""
        for mod in self.modules:
            mod.modlevel = self.modlevel + 1
            group = getattr(mod, "update_modlevel", None)
            if group:
                mod.update_modlevel()

    def get_signal(self, signal_name: str) -> GenericSignal:
        """! @brief Search for and return a glue signal matching 'signal_name'"""
        return next(
            (sig for sig in self.signals if sig.code_name == signal_name), None
        )

    def add_signal(self, signal: GenericSignal) -> bool:
        """! @brief Add a new GlueSignal to this AsModuleGroup.
        If a signal with the same code_name is already present, do nothing.
        Returns True on success, False if the signal has a duplicate name."""
        # Check if the new signal has a duplicate name
        if any((signal.code_name == sig.code_name for sig in self.signals)):
            return False
        # Otherwise, associate the signal with this group and add it
        if not isinstance(signal, GlueSignal):
            # Don't assign GlueSignals as they "belong" to their source module
            signal.assign_to(self)
        self.signals.append(signal)
        return True

    def add_constant(self, const: Constant) -> bool:
        """! @brief Add a new Constant to this AsModuleGroup.
        If a constant with the same code_name is already present, do nothing.
        Returns True on success, False if the Constant has a duplicate name."""
        # Check if the new constant has a duplicate name
        if any((const.code_name == c.code_name for c in self.constants)):
            return False
        # Otherwise, associate the constant with this group and add it
        const.assign_to(self)
        self.constants.append(const)

    def get_constant(self, constant_name: str) -> Constant:
        """! @brief Return the Constant with the code_name 'constant_name'.
        If no Constant exists with this name, returns None."""
        return next(
            (
                const
                for const in self.constants
                if const.code_name == constant_name
            ),
            None,
        )

    def get_module(self, module_name: str) -> AsModule:
        """! @brief Search for and return a submodule matching 'module_name'."""
        return next(
            (mod for mod in self.modules if mod.name == module_name), None
        )

    def __minimize_port_names__(self, exclude: list = None):
        """! @brief Remove sections of the port names so they are still unique
        but as short as possible.
        This function only removes redundant strings delimited by underscores.
        The resulting names will be all lowercase!"""
        ports = self.get_full_port_list()
        for port in ports:
            port.code_name = as_help.minimize_name(port.code_name, exclude)

    ##
    # @addtogroup automatics_cds
    # @{

    def assign_port_to_register(
        self, register_num: int, port: Port, to_bit_index: int
    ) -> bool:
        """! @brief Assign a Port as a part of a register as a data sink.
        @param register_num  Define the number of the register to assign to
        @param port  The Port to assign to the register
        @param to_bit_index  The bit offset to assign to.
                             register bit map: (31 downto 0)
        """
        if to_bit_index > 31 or to_bit_index < 0:
            LOG.error("Index for register assignment is out of bounds!")
            raise ValueError(to_bit_index, "Out of bounds!", port)
        # If the register index does not have a register associated, add them
        while self.register_count <= register_num:
            if register_num == self.register_count:
                self.add_register(Register.status)
            else:  # Empty registers for empty spots
                self.add_register(Register.none)
        # Update register type if necessary
        if self.register_config[register_num] == "AS_REG_NONE":
            self.modify_register_type(register_num, Register.status)
        elif self.register_config[register_num] == "AS_REG_CONTROL":
            self.modify_register_type(register_num, Register.both)

        # Get or create the register assignment signal
        try:
            reg_signal = self.reg_assign_map_status[register_num]
        except KeyError:
            reg_signal = self.define_signal(
                "s_register_id{}_status".format(register_num),
                data_type="std_logic_vector",
                data_width=Port.DataWidth(31, "downto", 0),
            )
            self._assign_to_register(register_num, reg_signal)

        # Get or create the source signal
        if isinstance(port, GenericSignal):
            source = port
        else:
            self.__update_generics_list__()
            port.glue_signal = self.define_signal_based_on_port(port)
            self.chain.connect(port, port.glue_signal)
            source = port.glue_signal
        # Assign the source signal to the register assignment signal
        reg_signal.assign_to_this_vector(source, to_bit_index)

    def assign_register_to_port(
        self, register_num: int, port: Port, from_bit_index: int
    ):
        """! @brief Assign part of a register as a data source to a Port.
        @param register_num  Define the number of the register to assign from
        @param port  The Port to assign the register value to
        @param from_bit_index  The bit offset to assign from.
                               register bit map: (31 downto 0)"""

        # If the register index does not have a register associated, add them
        while self.register_count <= register_num:
            if register_num == self.register_count:
                self.add_register(Register.control)
            else:  # Empty registers for empty spots
                self.add_register(Register.none)

        # Update register type if necessary
        if self.register_config[register_num] == "AS_REG_NONE":
            self.modify_register_type(register_num, Register.control)
        elif self.register_config[register_num] == "AS_REG_STATUS":
            self.modify_register_type(register_num, Register.both)

        # Get or create the register assignment signal
        try:
            reg_signal = self.reg_assign_map_control[register_num]
        except KeyError:
            reg_signal = self.define_signal(
                "s_register_id{}_control".format(register_num),
                data_type="std_logic_vector",
                data_width=Port.DataWidth(31, "downto", 0),
            )
            self._assign_from_register(register_num, reg_signal)

        self.__update_generics_list__()
        if isinstance(port, GenericSignal):
            target = port
        else:
            sig = self.define_signal_based_on_port(port)
            self.chain.connect(port, sig)
            target = sig

        # Assign from the register to the target signal
        reg_signal.assign_from_this_vector(target, from_bit_index)

    def define_port(
        self,
        name: str,
        code_name: str = "",
        direction: str = "in",
        data_type: str = "std_logic",
        data_width: tuple = None,
        fixed_value: str = "",
    ) -> Port:
        """! @brief Add a port to this module group.
        @param name: The ports base name (without pre- or suffixes)
        @param code_name: The ports name as it appears in VHDL code. [name]
        @param direction: Direction or data ['in'], 'out' or 'inout'.
        @param data_type: The ports VHDL data type. [std_logic]
        @param data_width: The width of vector data types. Use a tuple to define.
                           Example: (7, 'downto', 0); [None]
        @param fixed_value: Optionally set a fixed value for the port. The value of
                            this parameter is directly copied into code!
        @return  The created GenericSignal object."""
        if not code_name:
            code_name = name
        if data_width:
            data_width = Port.DataWidth(*data_width)
        else:
            data_width = Port.DataWidth(1, None, None)
        port = Port(
            name,
            code_name,
            direction,
            port_type="external",
            data_type=data_type,
            optional=False,
            data_width=data_width,
        )
        if fixed_value:
            self.__port_set_value__(port, fixed_value)
        self.add_port(port)
        return port

    def port_set_value(self, portname: str, value: str):
        """! @brief Set a fixed value for a port of this module group.
        @param portname: The name of the Port to modify
        @param value: The fixed value to set for the Port
        """
        port = self.get_port(portname)
        self.__port_set_value__(port, value)

    def __port_set_value__(self, port: Port, value: str):
        if (port.port_type + "_port") in Port.rule_conditions:
            port.add_rule(
                (port.port_type + "_port"), "set_value({})".format(value)
            )
        else:
            port.add_rule("source_present", "set_value({})".format(value))
        port.remove_condition("both_present")
        if port.direction == "in":
            port.in_entity = False

    def define_signal_based_on_port(
        self, port: Port, name: str = "", fixed_value=None
    ) -> GenericSignal:
        """! @brief Define, create and add a signal object to this module group,
        based on an existing port.
        The provided Port is only used as a template for the created signal.
        @param port  The Port to use as a template
        @param name  The name for the signal to create
        @param fixed_value  (optional) Set a fixed value to assign to the signal
        """
        signame = ""
        if name:
            signame = name
        else:
            signame = port.code_name + "_glue"

        self.chain._extract_generics(get_parent_module(port))
        resolve_generic(port)
        signal = self.define_signal(
            signame, port.data_type, port.data_width, fixed_value
        )
        signal.generics = copy.copy(port.generics)
        return signal

    def define_signal(
        self,
        name: str,
        data_type: str = "std_logic",
        data_width: tuple = None,
        fixed_value=None,
    ) -> GenericSignal:
        """! @brief Define, create and add a signal object to this module group.
        @param name  The name for the signal to create
        @param data_type  The data type to set for the signal
        @param data_width  The data width to define for the data type (optional)
        @param fixed_value  (optional) Set a fixed value to assign to the signal
        """
        if data_width:
            data_width = Port.DataWidth(*data_width)
        else:
            data_width = Port.DataWidth(1, None, None)
        signal = GenericSignal(name, data_type=data_type, data_width=data_width)
        if fixed_value:
            glue = GlueSignal(
                name=fixed_value,
                code_name=fixed_value,
                port_type=signal.port_type,
                data_width=signal.data_width,
                optional=False,
            )
            glue.is_signal = False
            signal.glue_signal = glue
            signal.incoming.append(glue)
            glue.set_connected()
            signal.set_connected()
        # Assign signal to this module group and return it
        if self.add_signal(signal):
            return signal
        return None

    def signal_set_value(self, signalname: str, value: str):
        """! @brief Set a value for a signal of this module group.
        @param signalname  The name of the signal to modify
        @param value  The value to set as a string"""
        signal = self.get_signal(signalname)
        if signal is None:
            raise AsNameError(
                signalname,
                self,
                "Could not find signal with given name!",
                "Signal and searched module:",
            )
        signal.add_rule("type_signal", "set_value({})".format(value))

    def remove_signal(
        self, signal: GenericSignal = None, signal_name: str = ""
    ):
        """! @brief Remove a signal from this module group.
        Either a signal object or the name of the signal can be provided.
        @param signal  The signal object to remove from this module group
        @param signal_name  The name of the signal to remove from this module group
        """
        if not signal and signal_name:
            signal = self.get_signal(signal_name)
        if signal:
            try:
                self.signals.remove(signal)
            except ValueError:
                LOG.warning(
                    "Could not remove signal '%s' from '%s' - does not exist!",
                    signal.code_name,
                    self.name,
                )

    ## @}

    # Overwritten
    ## @ingroup automatics_connection
    def __update_connections__(self):
        for port in self.get_full_port_list(include_signals=True):
            con = False
            if isinstance(port, GlueSignal):
                con = any((port.incoming is not None, bool(port.outgoing)))
            elif isinstance(port, GenericSignal):
                con = any(
                    (
                        port.glue_signal is not None,
                        len(port.incoming) + len(port.outgoing) > 0,
                    )
                )
            elif isinstance(port, Port):
                con = bool(bool(port.incoming) and bool(port.outgoing))

            port.set_connected(con)
